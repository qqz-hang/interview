一.Lucene 
	1.Lucene是开源的全文搜索引擎工具包（一堆jar包）
	
	2.Lucene实现全文搜索是怎样实现的？
		（1）采集数据  （2）创建索引  （3）用户搜索   （4）搜索索引   （5）结果展示
	
	3.创建索引是怎样实现的？
		（1）准备数据 （2）准备索引目录  （3）准备好IndexWriter,设置好分词器（需要传入二个参数： Directory directory；IndexWriterConfig conf）
		 （4）把数据封装成document对象  （5）用IndexWriter把document对象添加进索引库中
	
	4.搜索索引是怎样实现的？
		（1）准备索引目录 （2）准备IndexSearch，准备分词器  （3）准备搜索的关键字  (4)使用IndexSearch检索关键字  （5）处理结果
		
	5.分词原理（倒排文档）
		首先用户传入关键字，然后在索引区匹配到该关键字的文档ID，再根据得到的文档ID在数据区获得相应的文档，最后把文档展示给用户
		
二.ElasticSearch
	1.是一个基于Lucene的搜索服务器
	
	2.优点
		（1）分布式的实时文件存储，每个字段都被索引并可被搜索
		（2）可以扩展到上百台服务器，处理PB级结构化或非结构化数据：KB-MB-GB-TB-PB
		（3）高度集成化的服务，你的应用可以通过简单的 RESTful API、各种语言的客户端甚至命令行与之交互。
		（4）上手Elasticsearch非常容易，它拥有开瓶即饮的效果（安装即可使用）
	
	3.缺点
		（1）在需要添加新数据与新字段的时候，之前的数据需要重新同步，对数据的管理有很多困难。

	4.ES的安装&Kinbana
		只需要官方下载ES的运行包，然后启动ES服务即可
		
	5.ES的结构
		（1）index:索引库：相当于mysql的数据库
		 (2)type:类型：相当于mysql中的表
		 (3)document:文档：相当于mysql中的一条数据
		 (4）field:数据字段：相当于mysql中的一个字段
	
	6.ES的CRUD实现
		（1）：添加：获取Client对象；创建索引库；准备数据；把内容设置进去
		（2）：获取（查询）：获取Client对象；获取指定的数据；
		（3）：修改：获取Client对象；修改指定的文档；设置修改的内容；把设置修改好的内容添加进去
		（4）：删除：获取Client对象；删除指定的文档；
		（5) : 批量操作：获取Client对象；得到批量建造器；准备数据；处理结果
		
	7.简单查询和DSL查询与过滤看Ximd
	
	8.分词器的安装
		把解压的分词器文件内容放置于ES根目录/plugins/ik
		
	9.分词词典的配置
		config/IKAnalyzer.cfg.xml中配置
		
	10简单映射和全局映射看Ximd和文档
	
	11.elasticsearch 的倒排索引是什么？
		传统的我们的检索是通过文章，逐个遍历找到对应关键词的位置。
		而倒排索引，是通过分词策略，形成了词和文章的映射关系表，这种词典+映射表即为倒排索引。
		有了倒排索引，就能实现 o（1）时间复杂度的效率检索文章了，极大的提高了检索效率
		
	12.elasticsearch 索引数据多了怎么办，如何调优，部署？
		索引数据的规划，应在前期做好规划，先设计好在编码，这样能有效避免数据的急增
		调优：（1）：动态索引层面：基于模板+时间+rollover api 滚动创建索引
			  （2）：存储层面：冷热数据分离存储，热数据（比如最近 3 天或者一周的数据），其余为冷数据。
							   对于冷数据不会再写入新数据，可以考虑定期 force_merge 加 shrink 压缩操作，节省存储空间和检索效率。
			  （3）：部署层面：结合 ES 自身的支持动态扩展的特点，动态新增机器的方式可以缓解集群压力---------》属于应急策略
			  
	13.elasticsearch 是如何实现 master 选举的？
		有前提：（1）只有候选主节点（master：true）的节点才能成为主节点
				（2）最小主节点数（min_master_nodes）的目的是防止脑裂
				 选择主节点成功返回对应 Master，否则返回 null。
		流程：第一步：确认候选主节点数达标，elasticsearch.yml 设置的值
			  比较：先判定是否具备 master 资格，具备候选主节点资格的优先返回；若两节点都为候选主节点，则 id 小的值会主节点。注意这里的 id 为 string 类型。
			  
			  https://blog.csdn.net/tianyaleixiaowu/article/details/97373083
				
	
三.SpringCloud-应用架构的演变
	1.什么是单体架构：所有的模块，组件等都在一个应用中应用最终打成一个(war,jar)包使用一个容器(Tomcat)进行部署，通常一个应用享用一个数据库
				  单体应用中我们通常把应用分为三个组成部分：持久层，业务层，表现层
			
	2.单体架构的优缺点
		优点：（1）易于开发 ：架构简单，技术成本低 
			  （2）易于测试 ：所有功能在一个项目，方便测试
			  （3）易于部署 ：一个Tomcat就可以实现部署，简单方便
			  （4）业务较少时，没有任何问题
		缺点：（1）代码臃肿不方便开发维护(代码可读性差)
			  （2）代码编译系统启动变慢
			  （3）系统扩展性能变差(牵一发而动全身)
			  （4）无法针对某一个业务做扩展(集群)
			  （5）对大数据量,高并发量的处理不占优势
			  （6）技术选型单一
			  （7）模块/业务耦合度高
			
	3.什么是集群？
		集群就是多个应用分散在不同的服务器，每个应用跑的是同一套代码做的是相同的工作，以提高系统的整体性能，
		简单理解"多个人在一起做相同的事情，每个人做的事情都是完整的
		例如：超市的收银台
		
	4.为什么要做集群？
		为了提升应用的并发作业能力和防止应用的单节点故障(一个Tomcat挂了，应用就挂了)我们通常会对应用做集群
		
	5.什么是负载均衡？
		一个 请求分发的功能的组件
		
	6.为什么要有负载均衡组件？
		当我们的应用做了集群，那么就会存在多个应用节点，多个应用将会暴露多个访问地址(ip:port)，
		那客户端是不知道该访问哪个应用节点的，这个时候我们就需要有一个请求分发的功能的组件(负载均衡器)将客户端的请求相对平均的分发多个应用节点上
		
	7.为什么我们的项目要用Nginx负载均衡器？
		（1）可以高并发连接：官方测试Nginx能够支撑5万并发连接，实际生产环境中可以支撑2~4万并发连接数。
		（2）内存消耗少
		（3）成本低廉:Nginx为开源软件;以免费试用，并且可用于商业用途。
		(4)支持热部署
		
	8.Nginx负载均衡算法有哪些？？
		（1）轮询(round robin) : 依次将请求分配到各个后台服务器中，默认的负载均衡方式
		（2)权重(weight) ： 根据权重值将请求分配到后台服务器中，权重值越大，分配比例越高
		 (3)IP_HASH：按照ip地址进行hash运算，同一ip的请求会被分配到相同的机器上
		 (4)url_hash ： 根据请求的url的hash值将请求分到不同的机器中。
	
	总之,当我们的单体应用没办法支撑较高的并发请求时，我们可以对应用做集群，
	同时加入负载均衡器来提升应用的作业能力，
	甚至我们也可以在数据库层也做集群(如主从复制)，这样的架构有一定的并发处理能力，也能满足一定的复杂业务需求
	
	
	9.什么是分布式？
		将应用按照业务进行拆分成多个子应用，多个子应用部署在不同的服务器中，多个子应用组成一个完整的系统，所有的子系统一起工作相互通信相互协调才能完成最终的业务流程，缺一不可
		例如：厨师（洗菜，切菜，炒菜）
	
	10.什么是SOA？ 
		面向服务的分布式架构；它的思想是每个子应用可以通过网络通信协议向其他子应用提供服务或者消费服务；
		们可以简单的理解为SOA把分布式架构划分成表示层和服务层，
		服务层中包含了业务逻辑和相关流程，只需要对外暴露服务即可，表现层负责处理和页面的交互。
		这样的划分好处在于系统之间调用的方便性，如用户子系统只需要调用订单子系统的服务层即可完成应用之间的通信。这样的结构划分提高了应用的重用性，业务逻辑也变得可组合
		
	11.SOA的优缺点
		SOA架构中有重要的两个角色，服务消费者(Consumer)和服务提供者(Provider)即服务调用者和服务被调用者
		优点：模块拆分，使用API通信，降低模块之间的耦合度
			  项目拆分多个子应用，每个子应用业务简单，代码简单，方便维护开发。
			  不同技术人员可以负责不同的子应用
			  提高服务之间的重用性，业务逻辑可组合
			  
		缺点：服务之间的API接口开发增加了工作量，
			  SOA服务之间的网络通信调用对性能有一定的影响(尽管很小).
			  相对于单体应用来说，技术,人力成本较高。
			  部署和运维相对麻烦
			  
	12.什么是微服务架构
		把单一应用进行细粒度的拆分成多个小(微)的服务相，每个服务独立运行，
		每个服务只需要专注一个业务即可，并且每个服务都可以有自己的数据库(分库)，服务之间互协调配合完成整个系统的业务
		
	13.微服务的优缺点
		优点：单个服务业务简单，代码简单方便开发维护
			  服务之间无耦合，服务之间升级维护互不影响
			  轻量级HTTP通信机制，使得的不同的服务可以采用不同的编程语言
			  微服务有极强的扩展能力,业务量大的服务可以再次拆分服务，也可以进行集群部署，剔除服务也很方便
			  更大的系统负载能力和容错能力(集群)
			  于开发人员来说,通常只需要关注单一服务,新员工上手也比较快
		缺点：分布式事务 ：服务通信机制增加了事务的复杂性
			  部署麻烦 ：微服务众多，部署麻烦，需要借助容器技术和自动化部署工具
			  技术成本高 ：微服务架构本身比较复杂,技术成本高
			  
四.SpringCloud
	1.什么是SpringCloud？为什么要使用它？
		SpringCloud是一个基于Spring Boot实现的服务治理工具包，用于微服务架构中管理和协调服务的。Spring Cloud是一系列框架的有序集合
		它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，让微服务架构的落地变得更简单
		
	2.SpringCloud的主要组件及其作用
	
		Eureka：服务注册与发现
		（1）：Eureka：服务注册与发现
			作用：服务注册----》微服务(EurekaClient)在启动的时候会向EurekaServer提交自己的服务信息(通信地址如:服务名,ip,端口等)，
								在 EurekaServer会形成一个微服务的通信地址列表存储起来。 — 这叫服务注册
				  服务发现----》微服务(EurekaClient)会定期(RegistryFetchIntervalSeconds:默认30s)的从EurekaServer拉取一份微服务通信地址列表缓存到本地。
								当一个微服务在向另一个微服务发起调用的时候会根据目标服务的服务名找到其通信地址，然后基于HTTP协议向目标服务发起请求。—这叫服务发现
				  服务续约----》微服务(EurekaClient)采用定时(LeaseRenewalIntervalInSeconds:默认30s)发送“心跳”请求向EurekaServer发请求进行服务续约，
								其实就是定时向 EurekaServer发请求报告自己的健康状况，告诉EurekaServer自己还活着，不要把自己从服务地址清单中剔除掉，
								那么当微服务(EurekaClient)宕机未向EurekaServer续约，或者续约请求超时，注册中心机会从服务地址清单中剔除该续约失败的服务。
				  服务下线----》微服务(EurekaClient)关闭服务前向注册中心发送下线请求，注册中心(EurekaServer)接受到下线请求负责将该服务实例从注册列表剔除
				  
		（2）Eureka的工作流程
			1.微服务启动会将自己的服务名，IP，端口等信息注册到Eureka的服务端（也就是注册中心），
			2.在Eureka的服务端（也就是注册中心）形成服务通信地址列表
			3.每个微服务会把注册中心中的服务通信地址列表拉取到本地储存（默认每隔30秒拉取一次）
			4.挡一个微服务调用另一个微服务的时候，会根据被调服务名找到服务通信地址列表中对应的微服务的服务名进而获得服务的通讯地址，然后发起Http调用
			
		 （3）Eureka自我保护机制
			默认情况下，当EurekaServer接收到服务续约的心跳失败比例在15分钟之内低于85%，EurekaServer会把这些服务保护起来，即不会把该服务从服务注册地址清单中剔除掉，
			但是在此种情况下有可能会出现服务下线，那么消费者就会拿到一个无效的服务，请求会失败，那我们需要对消费者服务做一些重试，或在熔断策略。
			
		 （4）Eureka集群
			当微服务数量达到上百之数，一个EurekaServer所需要承担的压力会比较大，
			加上单节点故障问题可能会导致整个微服务不可被访问，由于EurekaServer在微服务中举足轻重，我们需要考虑对EurekaServer做高可用集群。
		 （5）Eureka的弱一致性
				分布式领域有个CAP理论，指的是在一个分布式系统中，
				一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。
			Eureka选择了CAP理论中的AP，保证了可用性和分区容错，放弃了数据一致性。
			当Eureka自身发生故障，或集群发生分网络分区问题时(多个Eureka之间不可通信)需要保证服务可用，还能够正常的提供服务注册和发现功能，
			那么EurakServer就必须选择可用性，放弃一致性，所以多个Eureka集群节点间的数据并不是强一致性的(多个EurekaServer之间数据不会实时同步，但是最终可能会同步数据)
		 
		 （6）Eureka参数调优
				1.续约频率，默认30s；
				2.每分钟需要收到的续约次数默认0.85
				3.来指定Eureka Server定时清除过期数据的频率(默认是60/s)
				4.关闭Eureka Server缓存
				5.将定时获取服务注册列表时间调整
				6.来修改心跳频率时间（默认是30S）
				
		 （7）Eureka设置账号认证
			我们可以直接通过浏览器访问Eureka的控制台界面看到注册的服务列表，这是一个很危险的操作，
			在生产环境中我们需要有相关的认证机制，即需要通过输入用户名和密码认证后才能访问Eureak的控制台界面
			
			
		服务通信的实现
		Ribbon+RestTemplate实现服务之间的通信
		Ribbon
		（1）Ribbon就是一个客户端负载均衡器，做请求的分发。Ribbon可以按照负载均衡算法(如简单轮询，随机连接等)向多个服务发起调用
		
		（2）Ribbon的工作机制是什么？？？
			我们将user-server(用户服务)做集群处理，增加到2个节点(注意：两个user-server(用户服务)的服务名要一样，ip和端口不一样)，
			在注册中心的服务通信地址清单中user-server(用户服务)这个服务下面会挂载两个通信地址 。 
			order-server(订单服务)会定时把服务通信地址清单拉取到本地进行缓存， 
			那么当order-server(订单服务)在向user-server(用户服务)发起调用时，需要指定服务名为 user-server(用户服务)；
			那么这个时候，ribbon会根据user-server(用户服务)这个服务名找到两个order-server的通信地址 ， 
			然后ribbon会按照负载均衡算法(默认轮询)选择其中的某一个通信地址，发起http请求实现服务的调用
			
		（3）Ribbon怎样实现服务通信的？？
			加上Ribbon的负载均衡注解@LoadBalanced赋予RestTemplate有负债均衡的能力。
			
		（4）Ribbon内置算法有哪些？？？
			1.简单轮询服务列表来选择服务器。它是Ribbon默认的负载均衡规则。
			2.随机选择一个可用的服务器。
			3.忽略哪些短路的服务器，并选择并发数较低的服务器。
			
		（5）配置负载均衡算法
			1.注解全局配置：需要RandomRule配置成Bean即可 
			2.配置具体服务的负载均衡：@RibbonClient注解来实现
			
		（6）为什么在项目中我们用Feign，而不用Ribbon+RestTemplate实现服务之间的通信？
			在我们的项目中我们需要手动去拼接目标服务的URL，以及参数，可能参数比较简单的时候你没什么感觉，当地址比较复杂，参数比较多的时候，拼接URL就会得特别麻烦，而且显得好傻
			而客户端负载均衡Feign，它在Ribbon的基础上进行了封装，让服务的调用方式显得更简答和高级。
			把一些负责的url和参数处理细节屏蔽起来，我们只需要简单编写Fiegn的客户端接口就可以像调用本地service去调用远程微服务。
			
			
		Feign
		（7）什么是Feign？
		
		（8)Feign是怎样实现服务之间的通信的
			1.导包  
			2.在主配置类增加@EnableFeignClients标签 , 其value属性可以指定Feign的客户端接口的包,当然也可以省略value属性
			3.编写Feign的客户端接口，@FeignClient要写上你要调用服务的服务名
			3.方法直接从目标服务controller中拷贝，要保证：服务名要一致 ， url路径要一致 ， 参数要一致 ， 返回值类型要一致。
			
		（9）说说Feign的工作原理
			当请求发起，会使用jdk的动态代理方式代理接口，生成相应的RequestTemplate，Feign会为每个方法生成一个RequestTemplate同时封装好http信息，如：url，请求参数等等
			最终RequestTemplate生成request请求，交给Http客户端(UrlConnection ,HttpClient,OkHttp)。然后Http客户端会交给LoadBalancerClient，使用Ribbon的负载均衡发起调用。
			可以在yml中进行一些参数配置：负载均衡配置，Feign的超时配置
			
		Feign开启Hystrix
			（1）是怎样实现的？？
				1.在微服务的yml配置文件中，开启熔断支持
				2.Fiegn接口熔断-fallbackFactory方式-------》触发托底是可以在控制台看到异常信息，方便我们调试。
					在Feign接口中使用工厂方式指定托底
					编写托底类，工程方式的托底类需要去实现 FallbackFactory接口 ，并指定泛型为“”Feign客户端接口
			
			
		熔断器Hystrix
		（1）Hystrix的作用是什么？
			Hystrix是处理依赖隔离的框架,将出现故障的服务通过熔断、降级等手段隔离开来，这样不影响整个系统的主业务，例如家里的保险开关
			
		（2）Hystrix的设计原则有哪些？
			1.防止单个服务异常导致整个微服务故障。
			2.快速失败，如果服务出现故障，服务的请求快速失败，线程不会等待。
			3.服务降级，请求故障可以返回设定好的二手方案数据（兜底数据）。给用户一个友好的提示
			4.熔断机制，防止故障的扩散，导致整个服务瘫痪。
			5.服务监控，提供了Hystrix Bashboard仪表盘，实时监控熔断器状态
			
		（3）Hystrix的功能有哪些？
			1.资源隔离
				线程池隔离：使用一个线程池来存储当前请求，线程池对请求作处理，设置任务返回处理超时时间，堆积的请求先入线程池队列。
							这种方式要为每个依赖服务申请线程池，有一定的资源消耗，好处是可以应对突发流量
				信号量隔离：使用一个原子计数器（或信号量）记录当前有多少个线程在运行，请求来先判断计数器的数值，
							若超过设置的最大线程个数则丢弃该类型的新请求，若不超过则执行计数操作请求来计数器+1，请求返回计数器-1，无法应对突发流量	
							
				线程池隔离与信号量隔离的区别有哪些？
					1.线程 ------》线程池：与调用线程非相同线程；           信号量：与调用线程相同 
					2.开销-------》线程池：排队、调度、上下文开销等；       信号量：无线程切换，开销低
					3.异步-------》线程池：支持；                           信号量：不支持
					4.并发支持---》线程池：支持（最大线程池大小）；         信号量：支持（最大信号量上限）
			2.服务熔断
				当服务不可访问了或者服务器报错了或者服务调用超过一定时间没返回结果，就立马触发熔断机制配合降级返回预先准备的兜底数据返回，
				不至于长时间的等待服务的相应造成大量的请求阻塞，也不至于返回一些错误信息给客户端，而是返回一些兜底数据，给与友好的提示。	
			3.降级机制
				当服务因为网络故障，服务器故障，读取超时等原因造成服务不可达的情况下返回一些预先准备好的数据给客户端。
			4.提供了请求缓存、请求合并实现 ， 在高并发的场景之下，Hystrix请求缓存可以方便地开启和使用请求缓存来优化系统，达到减轻高并发时请求线程的消耗、降低请求响应时间的效果。
				
		（4）说说Hystrix工作机制
			正常情况下，断路器处于关闭状态(Closed)，如果调用持续出错或者超时达到设定阈值，电路被打开进入熔断状态(Open)，
			这时请求这个服务会触发快速失败（立马返回兜底数据不要让线程死等），
			后续一段时间内的所有调用都会被拒绝(Fail Fast)，
			一段时间以后（withCircuitBreakerSleepWindowInMilliseconds=5s），保护器会尝试进入半熔断状态(Half-Open)，
			允许少量请求进来尝试，如果调用仍然失败，则回到熔断状态，如果调用成功，则回到电路闭合状态;
			例如你生病了........
			
		（5）Hystrix参数配置
			1.滑动窗口的大小，默认为20；过多长时间熔断器再次检测是否开启默认5000(5s)；错误率，默认50%
				每当20个请求中，有50%失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务。直到5s钟之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开。
			2.超时设置
			3.资源隔离模式
			4.最大请求设置
		
		
		 
		 
					
		服务监控：Hystrix Dashboard & Turbine
			（1）什么是Hystrix Dashboard？为什么要用它？
				用来监控Hystrix的熔断器状况的重要组件(又叫仪表盘)，它提供了数据监控,健康状态,熔断状态,并发数量等等信息,和友好的图形化展示界面,能让使用者很好的监控和分析熔断器的状态
				
			（2）什么是 Turbine？
				Dashboard 的缺点在于只能在单个服务中进行监控，如果我们需要对多个服务进行聚合监控就需要用到Turbine
				在微服务架构的项目中有成百上千的微服务，Hystrix Turbine的作用就是把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示如
				
			（3）Hystrix Dashboard在项目中怎样实现的？
				1.导入依赖
				2.开启Hystrix Dashboard：在主启动类打标签@EnableHystrixDashboard开启HystrixDashboard仪表盘
				3.在yml中指定HystrixDashboard监控的端点路径
				
			（4）Turbine是怎样实现的？
				1.导入依赖
				2..开启Turbine：主配置类打标签：@EnableHystrixDashboard 和 @EnableTurbine
				3.在yml中配置turbine
				
		
		服务网关-spring cloud zuul
			（1）什么是zuul？与什么作用
				简单理解zuul就是一个微服务的大门，所有的请求都需要通过zuul将请求分发到其他微服务，根据这一特性我们就可以在zuul做统一的登录检查，下游的微服务不再处理登录检查逻辑。
			
			（2）：zuul本身是一个独立的服务，默认集成了Ribbon，zuul通过Ribbon将客户端的请求分发到下游的微服务，所以zuul需要通过Eureka做服务发行，同时zuul也集成了Hystrix。
			
			（3）说说zuul的工作原理
				zuul的底层是通过各种Filter来实现的，zuul中的filter按照执行顺序分为了“pre”前置（”custom”自定义一般是前置），
				“routing”路由，“post”后置，以及“error”异常Filter组成，当各种Filter出现了异常，请求会跳转到“error filter”，
				然后再经过“post filter” 最后返回结果
				
				正常流程：请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。
				异常流程：整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。
						  如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。
						  如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。
			
			（3）zuul是怎样实现的？
				1.导入依赖
				2.配置类通过 @EnableZuulProxy（普rua可sei） 注解开启zuul服务功能。
				3.配置文件配置zuul，这里配置两个东西，一个是EurekaClien的配置，让zuul注册到EurekaServer,二个就是zuul的配置了
					zuul.prefix ： 作为统一的前缀，在浏览器访问的时候需要加上该前缀
					zuul.ignoredServices ： 忽略使用服务名方式访问服务，而是通过routes指定的路径进行访问
					zuul.routes : 配置服务的访问路径
					
			（4）说说自定义zuul的Filter是怎样实现的？
				Zuul提供了一个抽象的Filter:ZuulFilter我们可以通过该抽象类来自定义Filter，该Filter有四个核心方法
				
			（5）zuul的熔断器配置是怎样配置的？
				需要实现ZuulFallbackProvider接口，该接口提供了两个方法：getRoute用来指定熔断功能应用于哪些路由的服务，fallbackResponse方法为熔断功能时执行的方法(用来返回托底数据)
				
			（6）zuul的参数配置
				1.超时配置
				2.zuul的饥饿加载
				
				
		配置中心Spring Cloud Config
			（1）什么是配置中心？它的作用是什么？
				在分布式系统中，由于服务数量很多，为了方便服务配置文件统一管理我们需要用到置中心组件。
				在Spring Cloud中，分布式配置中心组件spring cloud config 它可以帮我们集中管理配置文件，修改配置无需重启服务 等，
				它支持配置文件放在配置服务的本地，也支持放在远程如Git仓库中集中管理
				
			（2）说说配置中心工作流程
				微服务通过ConfigClient向配置中心ConfigServer发起请求获取配置文件，配置中心从GIT仓库获取配置，然后再一路返回给微服务。	
				注意：ConfigServer可以脱离注册中心使用，但是如果客户端使用服务发现的方式指向配置中心就需要注册到注册中心了
					  EurekaServer的配置不能交给ConfigServer管理，因为必须要先启动EurekaServer才能启动ConfigServer
					 
			（3）配置中心的实现步骤
				服务端：ConfigServer
				1.导入依赖
				2.开启配置中心：在主配置类通过打@EnableConfigServer标签开启配置中心
				3.配置文件中：ConfigServer的配置文件做两个事情，1.注册到EurekaServer，2.配置码云地址
				
				客户端：ConfigClient
				1.导入依赖
				2.创建bootstrap.yml配置文件（bootstrap.yml的优先级高于application.yml或者其他配置来源，我们得让微服务优先从码云上拉取配置文件后才能做其他的事情。）
				
			（4）为什么要做配置中心集群？
				当配置中心服务宕机，那么整个微服务都没有办法再获取到配置文件，为了解决单节点问题，我们需要对配置中心做集群实现高可用。
				
			（5）配置中心集群的方案
				1.户端指向多个服务端地址
				2.服务发现方式
				
			（6）配置中心集群的实现
				服务发现方式：1.做了两个配置中心配置
							  2.修改配置中心客户端，使用服务发现方式拉取配置
							  
	1.SpringBoot和SpringCloud的区别？
		（1）SpringBoot专注于快速方便的开发单个个体微服务。SpringCloud是关注全局的微服务协调整理治理框架，
		（2）SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系
		 
	2.除了springCloud 你还知道哪些微服务架构？你用过吗？
		我还知道a里巴巴的那个，他使用Nacos作为服务注册中心，配置中心，还有服务发现的功能，相当于springcloud里面的Eureka
		使用Sentinel（神头楼）组件做熔断器 相当于springcloud里面的Hystrix，使用dubbo实现服务之间的通信，使用Gateway作为网关
		
				
			
五.RabbitMQ
		1.你们公司生产环境用的是什么消息中间件？
			我们公司用的是RabbitMQ；消息中间件有很多，比如说ActiveMQ，Redis等.
			ActiveMQ是老牌的消息中间件没法确认ActiveMQ可以支撑互联网公司的高并发、高负载以及高吞吐的复杂场景
			而RabbitMQ，他的好处在于可以支撑高并发、高吞吐、性能很高，同时有非常完善便捷的后台管理界面可以使用。他还支持集群化、高可用部署架构、消息高可靠支持，功能较为完善。
			Spring Boot默认已集成RabbitMQ
			
		2.AMQP是什么 ？
			AMQP是一套公开的消息队列协议，它旨在从协议层定义消息通信数据的标准格式， 为的就是解决MQ市场上协议不统一的问题
			
		3.RabbitMQ的下载安装
			RabbitMQ需要安装Erlang/OTP，并保持版本匹配，我们这个项目使用Erlang/OTP 20.3版本和RabbitMQ3.7.3版本
			erlang安装完成需要配置erlang环境变量

		1. RabbitMQ是什么？
			RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法
		
		2. 说说RabbitMQ的使用场景
			（1）服务间异步通信：提高了系统吞吐量。
			（2）顺序消费
			（3）服务解耦：系统间通过消息通信，不用关心其他系统的处理。
			（4）消除峰值：可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。
			（5）提高系统稳定性
			
		3.说一下RabbitMQ的组成部分有哪些？
			Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。
			Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑
			Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。 
			Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。
			Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。
			
		3.说一下RabbitMQ的工作原理
			（1）发送消息：
					生产者和Broker建立TCP连接
					生产者和Broker建立通道
					生产者通过通道消息发送给Broker，由Exchange将消息进行转发
					Exchange将消息转发到指定的Queue（队列）
			（2）接收消息
					消费者和Broker建立TCP连接 
					消费者和Broker建立通道
					消费者监听指定的Queue（队列）
					当有消息到达Queue时Broker默认将消息推送给消费者
					消费者接收到消息
					
		4.说一下RabbitMQ 常见模型及其工作流程
			（1）Helloworld-基本消息模型（ 一对一）
				发送端操作流程：创建连接；创建通道；声明队列；发送消息
				接收端：创建通道；创建连接；声明队列；监听队列；接收消息；ack回复
				
			（2）Work queues：ork queues与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息。
				 应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。
				 流程同上。
				 特点： 1.一条消息只会被一个消费者接收
						2.rabbit采用轮询的方式将消息是平均发送给消费者的
						3.消费者在处理完某条消息后，才会收到下一条消息
						4.可以使用basicQos方法和prefetchCount = 1设置，
						  简单理解就是一个消费者同时只能处理一个消息，直到它处理并确认了前一个消息后再处理新的消息，消费越快的人，消费的越多---》这就是我们所说的能者多劳
						  
			（3）发布/订阅模式
				特点：1.1个生产者，多个消费者
					  2.每一个消费者都有自己的一个队列
					  3.生产者没有将消息直接发送到队列，而是发送到了交换机
					  4.每个队列都要绑定到交换机
					  5.生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的
					  注意：交换机一方面：接收生产者发送的消息。另一方面：要知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。
					  
				分类：1.Fanout：广播，将消息交给所有绑定到交换机的队列 all
						特点：1. 可以有多个消费者
							  2.每个消费者有自己的queue（队列）
							  3.每个队列都要绑定到Exchange（交换机）
							  4.生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定
							  5.交换机把消息发送给绑定过的所有队列
							  6.队列的消费者都能拿到消息。实现一条消息被多个消费者消费
						应用场景：1.注册成功发送邮件和短信
								  2.消息推送
								  
					 2.	Direct：定向，把消息交给符合指定routing key 的队列 一堆或一个	
						  Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列					 
						  在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange 
						  所以要在消费者端，其所在队列指定了需要routing key匹配的消息
								  
					3.Topic：通配符，把消息交给符合routing pattern（路由模式）的队列 一堆或者一个
						注意：Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割
						通配符规则：#：匹配一个或多个词；           *：匹配不多不少恰好1个词
						特点：1.每个消费者监听自己的队列，并且设置带统配符的routingkey。
							  2.生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。	
							  
					4.Header模式
						特点：header模式取消routingkey，使用header中的 key/value（键值对）匹配 队列。 
						例如：据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种 通知类型都接收的则两种通知都有效。
						
		5.消息确认机制（ACK）
			如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！
			RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。
			自动ACK：消息一旦被接收，消费者自动发送ACK
			手动ACK：消息接收后，不会发送ACK，需要手动调用	
			我们用手动ACK   这样防止了消息的丢失
			
		6.如何避免消息的丢失？
			1.消费者的ACK机制。可以防止消费者丢失消息。设置成手动
			2.队列、Exchange都持久化和消息都持久化
			
		7.怎样实现队列、Exchange都持久化和消息都持久化？
			把durable设置为true ，消息持久化设置用一个自带的一个....
			
		8.你在项目中怎样使用的RabbitMQ？或者说你是怎样实现的消息推送？？
			1.导入依赖包
			2.在YML中配置MQ 例如：端口号，地址，账号，密码，手动签收等
			3.添加配置类：里面定义了邮件，短信，站内信的队列名称；定义了交换机的类型；定义了邮件队列，短信队列，站内信队列的Bean 
						  定义了邮件队列，短信队列，站内信队列绑定到交换机
			4.准备内容和准备数据，发送到MQ中
			5.消费者消费消息 ，同样消费者也要引入依赖包和yml配置
			
		9.你在使用中遇到了哪些问题？你是怎样解决的？
			（1）消息的重复问题
				解决：保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。
					  利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。
			（2）消息丢失问题
				解决：1.使用手动ACK机制
					  2.对交换机，队列和消息做持久化
		
		10.如何保证RabbitMQ消息的顺序性？
			拆分多个 queue，每个 queue 一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。
			
		11.消息基于什么传输？
			由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。
			信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。
			
			
六.SpringSecurity
	1.在你的项目中，你的认证与授权是用的什么思想？
		用的是RBAC，RBAC是基于角色的访问控制（Role-Based Access Control ）在 RBAC 中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限
		这就极大地简化了权限的管理
		
	2.为什么要用RBAC思想，而不用session进行认证？
		因为认证工具在传统的认证授权的基础上进行封装，让认证授权流程更简单，并且提供了一些强大的功能，如会话管理，缓存等 而SpringSecurity就是基于RBAC思想，所以我们在项目中用它
		
	3.你们为什么使用SpringSecurity来进行认证授权？
		Spring Security是一个能够为基于Spring的安全框架
		充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，
		减少了为企业系统安全控制编写大量重复代码的工作
		
	4.说一下SpringSecurity认证的流程
		 SpringSecurity是通过很多的过滤器链共同协作完成认证
		（1）用户发送认证请求，这里面包含了账号和密码
		（2）请求要经过SecurityContextPersistence（per色死疼死）Filter， 这个filter是整个filter链的入口和出口
		（3）请求进入UsernamePasswordAuthenticationFilter，它会把请求中的账号和密码封装成一个token对象
		（4）把token传入认证管理器进行认证
			1.认证管理器委托provider（per外der）进行认证，会把这个对象传入Dao....provider中，provider会调用userDetailsService把用户传入的账号拿到数据库中查询出用户数据（包含了权限等信息）
			2.会把tonken中的密码和数据库中查询出来的密码通过passwordEncoder密码编码器进行比对
		（5）认证成功，就重写封装一个对象，这个对象里面没有密码了（没有用了），有账号，权限信息等，返回给UsernamePasswordAuthenticationFilter
		（6）UsernamePasswordAuthenticationFilter会通过SecurityContextHodler把新封装的对象设置到SecurityContext中，并且返回给SecurityContextPersistenceFilter
		（7）在SecurityContextPersistenceFilter中会从SecurityContextHodler取出SecurityContext，储存到SecurityContextRepository中，清除Holder
		
	5.为什么要把认证后的对象信息保存到SecurityContext中？？？
		SecurityContext是一个和当前线程绑定的工具，在代码的任何地方都可以通过SecurityContextHolder.getContext()获取到登陆信息。
		
	6.在你的项目中，你是怎样实现认证的
		（1）把基于内存的方案修改为基于数据库中，因为我们要做在数据库中查询信息
		（2）定义密码编码器，默认的是不加密的方式，这样不符合业务需求，修改成BC方式
		（3）配置对登录页面跳转路径放行
		
	7.说一下SpringSecurity的授权流程
		（1）用户发送请求，在FilterSecurityInterceptor中会调用其父类AbstractSecurityInterceptor的beforeInvocation方法做授权之前的准备工作 
		（2）该方法中通过SecurityMetadataSource..getAttributes(object);获得资源所需要的访问权限 ，
			 通过SecurityContextHolder.getContext().getAuthentication()获取当前认证用户的认证信息
		（3）然后通过调用AccessDecisionManager.decide(authenticated, object, attributes);进行授权，该方法使用了投票机制来决定用户是否有资源访问权限
			 投票策略有三种：1.只需有一个投票赞成即可通过
							 2.需要大多数投票赞成即可通过，平票可以配置
							 3.需要所有的投票赞成才能通过
		（4）投票通过，放心请求响应的资源
		授权规则注意：细节的规则设置在前面，范围比较大的规则设置放在后面.
					  因为权限的设置是按照从上到下的优先级。及满足了最开始的权限设置，那么后面的设置就不起作用了
					  
	8.说一下方法授权的注解有哪些？它们的区别是什么？
		 安全授权有两种方式，一种是以url模式匹配的方式，另一种是方法上使用注解声明权限
		（1）@PostAuthorize（a死ruai死）：适合在方法执行后再进行权限验证，不用
		（2）@Secured（涩kiou而的）：标记方法需要有什么样的权限才能访问，@Secured注解授权是需要加上前缀“ROLE_”
		（3）@PreAuthorize：PreAuthorize适合进入方法前的权限验证，该标签不需要有固定的前缀   
			 注意格式“@PreAuthorize("hasAuthority（啊死瑞铁）('employee:add')")” ，hasAuthority不能省略，括号中是单引号。
		Spring Security默认是禁用注解的，要想开启注解，需要在授权服务器配置哪里开启Security
		
	9.说说记住我功能流程
		（1）认证成功UsernamePasswordAuthenticationFilter会调用RememberMeServices创建Token
				同时RemeberMeService 会调用TokenRepository将Token写入数据库,然后RemeberMeService通过Reponse.addCookie把Token写到浏览器的Cookies中
		  （2）当浏览器再次发起请求会进入RemeberMeAuthenticationFilter,该Filter获取到请求中的token交给RemeberMeService
		  （3）RemeberMeService调用TokenRepository去数据库中根据Token查询用户名
		  （4）调用UserDetilasService.loadUserByUsername根据用户名获取用户认证信息
		  （5）通过authenticationManager.authenticate认证管理器，做一次认证，然后把用户信息放入上下文对象中
	
	
	10.微服务授权方案有哪些
		（1）单点登录（CAS）：
		（2）分布式Session(会话)
		（3）客户端Token的认证方案
		（4）客户端 Token 与 API 网关结合
		
	11.这个项目的微服务授权方案是什么？
		Token+zuul+SpringSecurity+Oauth2+JWT
			（1）Oauth2（用来授权认证的）
				1.用Oauth2协议进行授权是因为不会使第三方触及到用户的帐号信息（如账号密码）
				2.Oauth2有  授权码模式：通过第三方应用程序的服务器，简单点说就是先获取授权码，在获取令牌。和实现第三方登录的流程差不多
							简化模式：不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，
							密码模式： 用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。
							客户端模式：客户端向"服务提供商"进行认证
				我做的这个项目用的是密码模式，因为我们这个项目目前还不考虑引入第三方平台，现在用密码模式就够用了
				
			（2）zuul
				我这个项目用的是zuul统一授权，因为用户访问资源服务都需要进行权限认证，麻烦，而zuul是整个项目的大门，所以让他负责token统一校验和统一授权
				
			（3）
			
	12.说一下你的zuul统一授权的流程
		（1）客户端发送请求，先到zuul
		（2）zuul获取请求头中的token，因为是第一次发送请求，所以token里面什么都没有，所以会到认证服务进行认证
		（3）认证成功返回token，客户端存储token （此时token里面包含有账号，还有该用户权限等信息）
		（4）客户端再次发送请求时，会携带token请求资源，这是zuul还是会取出token，验证是否有访问该资源服务的资格（资源ID等），有就放行，资源服务器负责对具体的资源进行授权。资源服务返回资源，没有就拦截
		（5）资源服务之间调用，比如说资源服务器A要调用资源服务器B，那么资源服务A会把token放到请求头里面，通过feign去调用另一个服务，资源服务器B会取出token中的权限信息，看是否有这个访问
		
		
七.Redis
	1.Redis是什么？
		Redis 是一个高性能的开源的、C语言写的Nosql（非关系型数据库），数据保存在内存中，以key-value形式存储.
		
	2.为什么项目中用redis存储数据？
		（1）1)存放在内存,还支持持久化.-存取速度快，并发能力强,数据安全高
		（2）支持value类型，包括string(字符串)、list(列表)、set(集合)、 zset(sorted set --有序集合)和hash（哈希类型 - map）。
		（3）支持多个语言客户端
		（4）还支持集群(支持高并发,海量数据)
		
	3.redis和memcached的相同点和不同点?   你有用过memcached?
		相同点:都是key-value Nosql,数据存储在内存中,读写效率高,都支持存储过期.
		不同点:redis支持持久化 ；redis支持存储类型更多
		没有用过，但是了解过，memcached是非关系型数据库，数据存储到内存，支持存储过期，读写能力非常高
		
	4.redis用在那些场景？
		中央缓存，计数器应用（新浪微博转发数、点赞数），设定有效期的应用等
		
	5.对value为string类型的常用操作
		set key value------》设置保存的数据
		get key------》根据key获取对应的value
		mset------》同时设置一个或多个key value
		keys *  //获取所有key列表
		del key  //删除key
		ttl key //查看key的过期时间
	
	6. 对value为list集合的常用操作
		list集合可以看成是一个左右排列的队列(列表)，队列：FIFO(先进先出)，控制从一边进，另一边出。.
		lpush key value //将一个或多个值 value 插入到列表 key 的表头(最左边)
		rpush key value //将一个或多个值 value 插入到列表 key 的表尾(最右边)
		lpop key //移除并返回列表 key 的头(最左边)元素。
		rpop key //移除并返回列表 key 的尾(最右边)元素。
	
	7.对set集合的常用操作
		sadd  key member //将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略
		srem key member //移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略
		smembers key    //返回集合 key 中的所有成员。
		
	8. redis是怎么保存数据?
		redis为了考虑效率,保存数据在内存中.并且考虑数据安全性,还做数据持久化,
		如果满足保存策略，就会把内存的数据保存到数据rdb文件，还来不及保存那部分数据存放到aof更新日志中。在加载时，把两个数据做一个并集。
		
	8.Redis 的持久化机制是什么？各自的优缺点？
		RDB：RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb
		AOF ：则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。
		
		（1）AOF文件比RDB更新频率高，优先使用AOF还原数据。
		（2）AOF比RDB更安全也更大
		（3）RDB性能比AOF好
		（4）如果两个都配了优先加载AOF
		
		
	9.redis为什么要淘汰数据？
		淘汰一些数据，达到redis数据都是有效的
		
	10.说说Redis的淘汰策略有哪些
		（1）volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
		（2）volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
		（3）allkeys-lru：从所有数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
		 
	11.用Java是怎样操作redis储存数据的？
		jedis是redis的客户端，我们选择用jedis来操作redis的    用的版本号是3.3.0
		
	12.事务的四大特效
		（1）原子性（Atomic）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
		（2）一致性（Consistency）：事务前后数据的完整性必须保持一致。
		（3） 隔离性（Isolation）： 多个事务并发执行时，一个事务的执行不应影响其他事务的执行
			 脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。
			 幻读：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录
			 不可重复读：
		（4）持久性（Durability）： 事务提交后，对系统的影响是永久的
		
	13.为什么要用 Redis /为什么要用缓存
		高性能：假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。
				将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。
				操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！
		高并发：直接操作缓存能够承受的请求是远远大于直接访问数据库的，减轻数据库的访问压力
		
	14.为什么要用 Redis 而不用 map/guava 做缓存?
		缓存分为本地缓存和分布式缓存。
			1.以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，
			并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
			2.使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性
			
	15.Redis为什么这么快？
		1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速
		2、数据结构简单，对数据操作也简单
		3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU
		
	16.为什么你的项目中要用hash数据结构储存数据？
		因为我要储存的是一个个对象，而hash数据结构能满足我的需求
		
	17.Redis中储存的数据过期了是怎样清除的？
		要依靠redis的过期策略，我简单说几种
			1.定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除
			2.惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除
			3.定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key
			
	18.Redis key的过期时间和永久有效分别怎么设置？
		EXPIRE和PERSIST命令。
		
	20.MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据
		redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。
		
	21.Redis如何做内存优化？
		选择合适的value数据结构储存数据，尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小
		
	22.你是怎样理解redis事务的
		总的来说，redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。
		
	23.Redis事务的三个阶段：
		事务开始 MULTI-----》命令入队------------》事务执行 EXEC
		
	24.Redis事务支持隔离性吗？Redis事务保证原子性吗，支持回滚吗
		Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。
		Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。
	
	25.如何保证缓存与数据库双写时的数据一致性？我在项目中就遇到了这个问题
		我先写缓存，再写数据库，缓存写成功，但写数据库失败或者响应延迟，则下次读取（并发读）缓存时，就出现脏读----》这个模式本身就是错误
		所以我改为先写数据库，再写缓存，如果数据库写成功，缓存写失败，那么先读数据库，再回写缓存的方式实现
		
	26.缓存穿透是什么？你是怎么解决的？
		缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
		解决方案：采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力
		
	27.缓存击穿是什么？你是怎么解决的？
		缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。
		解决方案：设置热点数据永远不过期。加互斥锁
		
		
八.Spring
	1.说说你对Spring的理解？
		（1）Spring是一个开源的轻量级控制反转(IOC)和面向切面编程(AOP)的容器框架，解决企业级应用开发的复杂性，即简化Java开发；
		（2）IOC（Inverse of control - 控制反转）：将创建对象的权利和依赖关系维护（字段赋值）交给Spring容器（不再使用以前new关键字创建对象）
		（3）AOP（Aspect Oriented Programming）：将相同的逻辑抽取出来，即将业务逻辑从应用服务中分离出来。然后以拦截的方式作用在一个方法的不同位置。例如日志，事务的处理
		
	2.我们为什么要用spring？
		（1）方便解耦，降低维护难度，提高开发效率（Spring相当于是一个大的工厂，它提供的IOC思想，可以将对象的创建和依赖关系维护都交给spring管理）；
		（2）spring支持AOP编程（spring提供面向切面编程，可以很方便的实现对程序进行权限拦截和运行监控等功能，可以将一些通用任务如安全、事务、日志等进行集中式管理，从而提供了更好的复用）；
		（3）方便程序的测试（Spring 对junit4支持，可以通过注解测试Spring 程序，非常便捷）；
		（4）方便集成各种优秀的框架（Spring并不强制应用完全依赖于Spring，开发者可自由选用Spring框架的部分或全部，也可以集成其他优秀的框架）；
		（6）Spring的DI机制降低了业务对象替换的复杂性，提高了组件之间的解耦
		
	3.spring的核心模块有哪些？分别有什么作用？
		Beans：负责Bean工厂中Bean的装配，所谓Bean工厂即是创建对象的工厂
		Core：这个模块即是负责IOC（控制反转）最基本的实现；
		Context：Spring的IOC容器，③Bean创建好对象后，由Context负责建立Bean与Bean之间的关系并维护。所以也可以把Context看成是Bean关系的集合；
		SpEl：即Spring Expression Language（Spring表达式语言）；
		
	4.Spring容器对象有几种创建方式？他们的区别是什么？
		Spring容器对象有两种：BeanFactory和ApplicationContext；
		区别：（1）BeanFactory是一个接口，aplicationContext是BeanFactory的子类，拥有更多的功能与方法；
			  （2)1.ApplicationContext默认是在读取配置文件的时候就会根据配置创建Bean对象（迫切加载）。而BeanFactory是在使用的时候才进行对象的创建（懒加载/延迟加载）
				(当然我们也可以在使用ApplicationContext的时候，可以通过配置让它也变成与BeanFactory一样的懒加载：）
				
	5.什么是DI？它有几种方式实现？
		给Spring中对象的属性字段赋值，这称为依赖注入DI
		依赖注入又分为xml注入和注解注入；
		注意：在xml中进行配置，但是这种方式必须有对应的setter方法，所有这种注入方式又称之为属性注入或setter方法注入；
			  注解注入：将注解写在setter方法上，也可以写在字段上，如果写在字段上可以不需要setter方法；
			  
	6.说一下Bean对象的生命周期
		Bean对象的生命周期指的是：从对象创建、初始化、调用执行到销毁的一个过程；
		（1)实例化实质是Spring容器调用Bean的无参构造创建Bean对象1
		（2）初始化实质上是Spring容器调用指定的初始化方法；
		（3）在容器关闭的时候（ApplicationContext对象没有close方法，其实现类有），Spring容器会自动调用指定的销毁方法；
		
	7.说一说DI分为哪几种？
		（1）构造器注入：
						1.根据参数名注入(推荐使用) 2.根据下标注入  3.根据参数类型注入  4.根据顺序注入
		（2）属性注入：
						1.普通属性 2.对象  3.集合  4.properties  5.数组
						
	8.谈谈你对AOP的理解
		（1）AOP：面向切面的编程，它的出现不是为了取代JAVA面向对象编程的思想，而是为了跟好的补充。 
		（2）面向切面编程的思想：我们可以把很多方法中的相同代码抽取出来，在需要用到的时候，切一刀，把抽取的代码加入就行了
		（3）使用AOP有二种方式：
								1.xml配置：配置的时候一定要记住三个要素：何时，何地，做什么事
											1.申明切点  2.申明切面：（1）引入事务管理器  （2）2.前置通知/后置通知/异常通知/最终通知/环绕通知(推荐使用)
											为什么用推荐使用环绕通知？ 答：因为 用于判断条件是否让目标方法执行，可以控制目标方法的执行
								2.注解：（1）1.在事务管理器中申明切面注解
										（2）2.创建方法申明切点
										（3）3.在目标方法上面加上 对应的通知注解
										
		（4）AOP可以用于：1.事务管理  2.性能测试  3.日志管理   4.权限管理
		（5）AOP的作用：1.减少代码量   2.解耦
		
	9.创建bean有哪些方式？
		（1）无参构造方法创建  （2）实例方法创建   （3）静态方法创建  （4）FctoryBean创建
		
	10.Spring有哪些注解可以定义（创建）Bean，哪些注解可以注入对象
		定义Bean：
			（1）@Component ：通用的注解，如果一个Bean不知道属于哪个层，可以使用
			（2）@Repository：: 对应持久层即 Dao 层，主要用于数据库相关操作。
			（3）@Service：:对应服务层
			（4）@Controller : 对应 Spring MVC控制层
		注入对象：
			（1）1.@Autowired : 自动按照类型注入。只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功。可以作用在变量或者方法上。
			（2）3.@Resource : 直接按照bean的id注入，可以独立使用。
			（3）@Value : 用于注入基本类型和String类型的数据。SpEL的写法：${表达式}
			
	11.简述一下代理模式是怎么回事
		（1）代理模式：就是一个人或者一个机构代表另一个人或者另一个机构采取行动，代理对象可以在客户端和目标对象之间起到中介的作用，比如说房屋中介
		（2）代理模式分为：
						1.静态代理：只代理一个 类 一个 方法 。如果这个 类 个 方法 ,我们还需要继续添加代码，而如果要代理多个 类 的 方法 ，我们也还需要添加相应的代理类，代码量增多了
						2.动态代理：
									（1）JDK动态代理：JDK动态代理只能代理有接口的类(JDK动态代理不支持没有接口的类)
									（2）CGLIB动态代理;没有接口的类使用CGLIB动态代理(类有没有接口都可以支持)
									
	12.Spring的AOP是使用什么技术实现的？
		（1） 反射+Proxy（普rua可se）动态代理：无需添加第三方依赖，但是效率上会付出代价，有实验数据表明，调用反射比直接调用方法的开销至少大10倍
		（2）Cglib实现代理：Cglib底层实现使用ASM技术，ASM是一个Java字节码操纵框架，它被用来动态生成类或者增强既有类的功能，总而言之，ASM技术轻量级
		
	13.BeanFactory与FactoryBean的区别？
		（1）：BeanFactory是个Factory，也就是IOC容器或对象工厂 ，所有的Bean都是由BeanFactory(也就是IOC容器)来进行管理的
		（2）：FactoryBean是个Bean，是一个能生产或者修饰对象生成的工厂Bean,它的实现与设计模式中的工厂模式和修饰器模式类似
		
	14.Spring 框架中都用到了哪些设计模式？
		（1）工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；
		（2）单例模式：Bean默认为单例模式。
		（3）代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；
		（4）模板模式
		
	15.Spring框架中有哪些不同类型的事件
		了解一点，有五种不同类型的事件
			（1）上下文更新事件   （2）上下文开始事件   （3）上下文停止事件   （4）上下文关闭事件    （5）请求处理事件
			
	16.说说Spring IoC的实现机制
		Spring 中的 IoC 的实现原理就是工厂模式加反射机制。
		
	17.BeanFactory 和 ApplicationContext有什么区别？
		（1）BeanFactory：是Spring里面最底层的接口而ApplicationContext接口是BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能
		（2）BeanFactroy采用的是延迟加载形式，即只有在使用的时候才进行加载实例化，而ApplicationContext，它是在容器启动时就创建了Bean，是迫切加载
		（3）注册方式：BeanFactory需要手动注册，而ApplicationContext则是自动注册。
		
	18.Spring配置文件包含了哪些信息
		Spring配置文件是个XML 文件，这个文件包含了类信息，描述了如何配置它们，以及如何相互调用。
		
	19.Spring框架中的单例bean是线程安全的吗？
		不是，spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。
		大部分时候 spring bean 无状态的，所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话，那就要开发者自己去保证线程安全了（把单例改为多例）
		
	20.Spring如何处理线程并发问题？
		使用ThreadLocal，他的理念是空间换时间，即每一个线程都有一个独立的变量副本，从而隔离了多个线程对数据的访问冲突
		
	21.在Spring中如何注入一个java集合？
		Spring提供以下几种集合的配置元素：
										（1）类型用于注入一列值，允许有相同的值。
										（2）类型用于注入一组值，不允许有相同的值。
										（3）类型用于注入一组键值对，键和值都可以为任意类型。
										（4）类型用于注入一组键值对，键和值都只能为String类型。
	
	22.@Autowired和@Resource之间的区别
		@Autowired默认是按照类型装配注入的，默认情况下它要求依赖对象必须存在
		@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入。
		
	23.@RequestMapping 注解有什么用？
		@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法
		
	24.Spring支持的事务管理类型， spring 事务实现方式有哪些？
		Spring支持两种类型的事务管理：
									（1）编程式事务管理：这意味你通过编程的方式管理事务，给你带来极大的灵活性，但是难维护。
									（2）声明式事务管理：这意味着你可以将业务代码和事务管理分离，你只需用注解和XML配置来管理事务。
									
	25.Spring事务的实现方式和实现原理
		方式：通过binlog或者redo log实现数据库层的事务提交和回滚
		原理：本质其实就是数据库对事务的支持
		
	26.说一下Spring的事务传播行为
		有七种：我简单说几种
			② PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。
			③ PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。
			① PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。
			
	27.说一下 spring 的事务隔离？
		（1）用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；
		（2）未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；
		（3）提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）
		（4）可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；
		（5）序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。
		
	28.你更倾向用那种事务管理类型？
		选择声明式事务管理，因为它对应用代码的影响最小，因此更符合一个无侵入的轻量级容器的思想。
		

九.SpringMVC
	1.我们为什么要使用Json格式传递数据？
		在实际开发中，通常需要和别的系统交换数据，数据交换的格式通常有XML和JSON等
		JSON是一种基于JavaScript 语法开放的轻量级数据交换格式，相对于XML，文档更小，结构清晰简洁，读写效率更高
		
	2.后台需要向前台传递JSON格式的数据，那么这个时候要把Java对象转换为JSON，怎么转？
		使用@ResponseBody注解
		
	3.什么是Spring MVC？简单介绍下你对Spring MVC的理解？
		SpringMvc是一个优秀的web层或表现层框架,通过把模型-视图-控制器分离，将web层进行职责解耦
		理解：1.SpringMvc底层是对Servlet的封装
			  2.SpringMvc是Spring的一个模块【web】，可以和Spring无缝集成
			  
	4.Spring MVC的优点
		（1）可以支持各种视图技术,而不仅仅局限于JSP；
		（2）与Spring框架集成
		（3）清晰的角色分配：前端控制器(dispatcherServlet) , 请求到处理器映射（handlerMapping), 处理器适配器（HandlerAdapter), 视图解析器（ViewResolver）。
		（4） 支持各种请求资源的映射策略。
		
	5.Spring MVC的主要组件？
		（1）前端控制器  （2）处理器映射器HandlerMapping  （3）处理器适配器HandlerAdapter  （4）处理器Handler（需要程序员开发） （5）视图解析器 ViewResolver  （6）视图View
		
	6.核心控制器（前端控制器）的职责是什么？
		它用来处理所有的HTTP请求和响应。
		
	7.Spring MVC的控制器是不是单例模式,如果是,有什么问题,怎么解决？
		是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。
		
	8.请描述Spring MVC的工作流程？
		1.请求来了之后统一交给前端控制器处理
		2.前端控制器会将请求交给HandlerMapping去映射【匹配请求】，找到能处理请求的处理器
		3.前端控制器会将处理器交给HandlerAdapter进行适配，找到对应的适配器
		4.执行业务处理器，处理之前还要做数据验证，数据格式化，数据转换等工作
		5.执行完业务处理之后返回一个ModelAndView对象
		6.前端控制器将ModelAndView对象交给视图解析器处理
		7.视图解析器返回逻辑视图，响应给用户
		
	9.MVC是什么？MVC设计模式的好处有哪些
		mvc是一种设计模式，模型（model）-视图（view）-控制器（controller），三层架构的设计模式
		好处：1.分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性。
			  2.有利于系统的并行开发，提升开发效率。
			  
	10.Spring MVC常用的注解有哪些？
		@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上
		@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。
		@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。
		
	11.@Controller注解的作用
		@Controller 用于标记在一个类上，使用它标记的类就是一个Spring MVC Controller 对象。分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping 注解。
		@Controller 只是定义了一个控制器类，而使用@RequestMapping 注解的方法才是真正处理请求的处理器
		
	12.@RequestMapping注解的作用
		RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。
		
	13.@ResponseBody注解的作用
		将后台给前台传递的对象数据格式化
	
	14.@PathVariable和@RequestParam的区别
		请求路径上有个id的变量值，可以通过@PathVariable来获取
		@RequestParam用来获得静态的URL请求入参 spring注解时action里用到。
		
	15.Spring MVC与Struts2区别
		（1）SpringMVC使用Servlet作为核心控制器，Struts2使用过滤器作为核心控制器；
		（2）(2)SpringMVC是spring中的一个模块，所以spring对于SpringMVC的控制器管理更加简单方便，而且提供了全注解方式进行管理，各种功能的注解都比较全面，使用简单；
		（3）(3)学习难度：Struts有很多新的技术点，比如拦截器、值栈及OGNL表达式，学习成本较高。SpringMVC比较简单，和容易上手；
		（4）开发效率SpringMVC要比struts2高
		（5）SpringMVC操作json比较简单，一个注解就可以实现
		
	16.如何解决POST请求中文乱码问题，GET的又如何处理呢？
		（1）解决post请求乱码问题：在web.xml中配置一个CharacterEncodingFilter中文编码过滤器，设置成utf-8；
		（2）get请求中文参数出现乱码解决方法有两个：①修改tomcat配置文件    ①修改tomcat配置文件
		
	17.如果在拦截请求中，我想拦截get方式提交的方法,怎么配置
		可以在@RequestMapping注解里面加上method=RequestMethod.GET。
		
	18.Spring MVC用什么对象从后台向前台传递数据的？
		通过ModelMap对象,可以在这个对象里面调用put方法,把对象加到里面,前台就可以通过el表达式拿到。
		
	19.怎么样把ModelMap里面的数据放入Session里面？
		可以在类上面加上@SessionAttributes注解,
		
	20.

		
		
十.SpringBoot
	1.什么是SpringBoot？
		它时一个用来简化Spring应用的初始搭建以及开发过程，简单的说，它使用maven的方式对Spring应用开发进行进一步封装和简化。
		
	2.为什么要使用Spring Boot？
		Spring Boot是为简化Spring项目配置而生，Spring Boot使编码更简单，使配置更简单，使部署更简单，使监控更简单。
		
	3.Spring Boot提供哪些功能？
		（1）无需手动管理依赖jar包的版本：Spring boot通过spring boot starter项目管理其提供的所有依赖的版本
		（2）spring-boot-starter-web:web支持，其实就是springmvc简化使用。
		（3）pring-boot-starter-jdbc:springboot对jdbc支持
		（4）Spring-boot-starter-data jpa:springboot对data jpa支持
		（5）Spring-boot-starter-mybatis:springboot对mybatis支持
		（6）Spring-boot-starter-test：springboot对test支持
	
	4.springboot运行方式是怎么样的？
		（1）在开发的时候：在ide中直接通过main函数启动
		（2）项目上线：先打包，在运行
		注意：SpringBoot可以支持热部署，需要加入一个依赖：spring-boot-devtools，如果代码改变了，直接点击热部署按钮，它会重新帮你启动，无需我们手动停止程序，在重新启动
		
	5.常见的模板引擎有哪些？SpringBoot使用的模板引擎是那种？为什么要用它？
		JSP、Velocity、Freemarker、Thymeleaf(法尔的礼服）
		SpringBoot使用的是Thymeleaf,语法更简单，功能更强大
		
	6.@SpringBootApplication和@MapperScan的作用是什么？@Transactional的作用是什么？
		@MapperScan的作用：会扫描该包下面的接口
		
		@Transactional：因为SpringBoot是支持事务的，所以只需要在业务层打上这个标签就可以了，代表开启事务管理，默认的事务传播机制是：
		
	7.如何获取获取自增Id？
	（1）在类上加入注解@Options，@Insert
		@Options(useGeneratedKeys = true, keyProperty = "id", keyColumn = "id") 
		@Insert("insert into Demo(name,password) values(#{name},#{password})") 
	（2）在写sql语句添加的时候，也可以获取
	
	8.Spring Boot 有哪些优点？
		（1）容易上手，提升开发效率
		（2）开箱即用，远离繁琐的配置
		（3）避免大量的 Maven 导入和各种版本冲突
		
	9.Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？
		启动类上面的注解是@SpringBootApplication，主要组合包含了以下 3 个注解：
		（1）@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。
		（2）@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项
		（3）@ComponentScan：Spring组件扫描。
		
	10.Spring Boot 自动配置原理是什么？
		@EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置的核心，
		@EnableAutoConfiguration 给容器导入META-INF/spring.factories 里定义的自动配置类。筛选有效的自动配置类。
		每一个自动配置类结合对应的 xxxProperties.java 读取配置文件进行自动配置功能
		
	11.你如何理解 Spring Boot 配置加载顺序？
		（1）先加载properties文件；
		（2）在加载YML文件
		（3）然后加载系统环境变量，命令行参数
		
	12.什么是 YAML？有什么特点？
		YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。 YAML 具有分层配置数据的特点
		
	13.YAML 配置的优势在哪里 ?（我们为什么要用YML作为我们的配置文件？
		（1）配置有序，在一些特殊的场景下，配置有序很关键
		（2）支持数组，数组中的元素可以是基本数据类型也可以是对象
		（3）简洁
		（4）有结构层次，更少混淆
		
	14.Spring Boot 是否可以使用 XML 配置 ?
		可以使用，通过@ImportResource 注解可以引入一个 XML 配置。
		
	15.spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?
		spring boot 核心的两个配置文件：
		（1）bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。
			一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不能被覆盖；
		（2）application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。
		
	16.什么是 Spring Profiles？
		它可以指定Bean的加载顺序
		
	17.比较一下 Spring Security 和 Shiro 各自的优缺点 ?
		（1）Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架
		（2）Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单
		（3）Spring Security 功能强大；Shiro 功能简单
		
	18.Spring Boot 中如何解决跨域问题 ?
		在后端通过 CORS 来解决跨域问题。传统的 SSM 框架中，也可以通过 CORS 来解决跨域问题，可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。
		
	19.什么是 CSRF 攻击？
		CSRF 代表跨站请求伪造。这是一种攻击，迫使最终用户在当前通过身份验证的Web 应用程序上执行不需要的操作。
		CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。
		
	20.什么是 Thymeleaf模板？
		Thymeleaf 是一个基于 Java 的模板引擎，使用 Thymeleaf 的主要优点是表示层和业务层的完全分离。
		程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。最后使用Thymeleaf 可以将这些结合起来，给出最终的输出页面。
	
	21.什么是 Swagger？
		Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱
		
	22.spring-boot-starter-parent 有什么用 ?
		（1）定义了 Java 编译版本为 1.8 
		（2）使用 UTF-8 格式编码
		（3）继承自 spring-boot-dependencies，这个里边定义了依赖的版本，所以我们在写依赖时才不需要写版本号。
		（4）执行打包操作的配置
	
	24.Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?
		Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，
		这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。
		
	25.运行 Spring Boot 有哪几种方式？
		（1）打包用命令或者放到容器中运行
		（2）用 Maven/ Gradle 插件运行
		（3）直接执行 main 方法运行
		
	26.开启 Spring Boot 特性有哪几种方式？
		（1）继承spring-boot-starter-parent项目
		（2）导入spring-boot-dependencies项目依赖
		
	27.如何使用 Spring Boot 实现分页和排序？
		使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法
		
	28.Spring Boot 中如何实现定时任务 ?
		（1）使用 Spring 中的 @Scheduled （死干jio的）的方式主要通过 @Scheduled 注解来实现。
		（2）使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可
		
	29.什么是 Spring Boot Stater ？
		可以一站式的获取你所需要的 Spring 和相关技术，例如，如果你想使用 Sping 和 JPA 访问数据库，只需要你的项目包含 spring-boot-starter-data-jpa 依赖项，你就可以完美进行。
		

十一.MyBatis
		1.Mybatis是什么？
			（1）1.MyBatis是一个ORM的数据库持久化框架；
			（2）Mybatis底层还是原生的JDBC代码，对JDBC代码的封装
		
		2.什么是框架？
			为解决一个开放性问题而设计的具有一定约束性的支撑结构
			
		3.什么是ORM？
			ORM：对象关系映射（Object Relational Mapping，简称ORM）：是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术；
		
		4.ORM框架映射方式
			（1）Sql操作方式（半映射或半自动）：把SQL配置到配置文件中，通过不同SQL中完成对象实体和数据库关系相互转换的操作（Mybatis的实现方式）
			（2）完整映射：直接使用对象实体和数据库关系进行映射，不用写SQL（简单的操作），由框架自己生成（JPA、Hibenate实现方式）
			
		5.ORM原理
			1.以一定的映射方式，把实体模型和数据库关系进行映射；
			2.ORM框架启动时加载这些映射和数据库配置文件连接数据库；
			3.ORM通过对最原生jdbc的封装，并提供更加便利的操作API；
			4.Dao通过ORM提供的便捷API以对象的方式操作数据库关系
		
		6.常见的ORM持久化框架有哪些？
			Hibernate（完整映射）；MyBatis（半映射）
			
		7.Mybatis相较于jdbc的优点？
			1.把sql语句从java代码中抽取出来，方便维护，并且修改sql时不用修改java代码；
			2.不用手动设置参数和对结果集的处理，让我们操作数据库更加简单；
			3.与JDBC相比，大大减少了代码量，提高了开发效率
			
		8.映射器实现步骤
			（1）根据需求，创建模型相关的Mapper接口，
			（2）在同包下编写映射文件：1.Mapper映射文件的命名空间，必须和接口的"完全限定名"一致
									   2.定义sql标签的id，需要和"接口的方法名"一致
			（3）在Mybatis核心配置文件中配置（或注册）Mapper映射文件；
			
		10.Log4j是什么？
			是一个日记框架，Log4j主要用于日志信息的输出。可以将信息分级别（严重fatal、错误error、警告warn、调式debug、信息info）按不同方式（控制台、文件、数据库）和格式输出；
			
		11.为什么需要动态Sql？
			串联 SQL 字符串在一起是多么的痛苦，确保不能忘了空格或在列表的最后省略逗号。动态 SQL 可以彻底解决这种痛苦。
			
		12.mybatis中的动态sql有哪些？
			(1)foreach 用于循环
			(2)if 用于判断 
			
			例如：批量插入数据 insert into product (name,price) values <foreach collection="list" separator="," item="p"> (#{p.name},#{p.price}) </foreach>
				  批量删除： delete from product where id in <foreach collection="list" separator="," item="id" open="(" close=")"> #{id} </foreach>
				  
		13.为什么要使用结果映射？
			（1）解决表字段名和对象属性名不一样的情况
			（2）：关联对象查询,在mybatis不会默认查询出来,需要自己查询结果并且通过resultMap来配置
			
		14.Mybatis关联映射处理方式
			嵌套结果: 发送1条SQL,查询所有的信息(本身+关联对象)
			嵌套查询：发送1+N条sql。
			
		15.Mybatis优缺点
			优点：
				（1）基于SQL语句编程，相当灵活，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；并可重用
				（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接
				（3）很好的与各种数据库兼容
				（4）能够与Spring很好的集成
			缺点：
				SQL语句的编写工作量较大，尤其当字段多、关联表多时，有点难搞
				SQL语句依赖于数据库，不能随意更换数据库
				
		16.Hibernate 和 MyBatis 的区别
			相同点：
				都是对jdbc的封装，都是持久层的框架，都用于dao层的开发
			不同点：
				1.hibernate要比ibatis功能强大很多。因为hibernate自动生成sql语句。
				2.ibatis可以出来复杂语句，而hibernate不能。
				3.ibatis要比hibernate简单的多。ibatis是面向sql的，不同考虑对象间一些复杂的映射关系
				
		17.	请说说MyBatis的工作原理
			1）读取 MyBatis 配置文件：
			2）加载映射文件
			3）构造会话工厂
			4）创建会话对象
			5）Executor 执行器操作数据库
			6）MappedStatement 对象储存要映射的 SQL 语句的 id、参数等信息。
			7）输入参数映射
			8）输出结果映射
			
		18.Mybatis都有哪些Executor执行器？它们之间的区别是什么？
			（1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。
			（2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，可以重复使用Statement对象。
			（3）BatchExecutor：执行update，将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），
				 它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理
				 
		19.Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？
			支持延迟加载
			原理：使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，如果发现a.getB（）为null，那么就会用储存的sql查询出来在把它设置进去
				  于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用
				  
		20.#{}和${}的区别
			（1）#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。
			（2）在使用 #{}时，MyBatis 会将 SQL 中的 #{}替换成“?”，配合 PreparedStatement 的 set 方法赋值，这样可以有效的防止 SQL 注入，保证程序的运行安全。
			
		21.在mapper中如何传递多个参数？
			我在项目中用的是Param注解传参法
			在xml中，#{}里面的名称对应的是注解@Param括号里面修饰的名称。
			
		22.如何获取获取自增Id？
			对于mybatis（支持主键自增的数据库）：在写添加sql语句的时候，用useGeneratedKeys="true" keyProperty="id"，keyColumn="id"
			
		23.当实体类中的属性名和表中的字段名不一样 ，怎么办
			（1）通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致
			（2）通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。
			
		24.Mapper 编写有哪几种方式？
			（1）：接口实现类继承 SqlSessionDaoSupport：
			（2）：使用 org.mybatis.spring.mapper.MapperFactoryBean
			（3）使用 mapper 扫描器：mapper.xml 中的 namespace 为 mapper 接口的地址（全限定）；
			
		25.使用MyBatis的mapper接口调用时有哪些要求？
			（1）Mapper接口方法名和mapper.xml中定义的每个sql的id相同。
			（2）输入参数类型和parameterType（）的类型相同。
			（3）输出参数类型和resultType的类型相同。
			（4）namespace即是mapper接口的类路径。
			
		25.Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？
			第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。
			第二种是使用sql列的别名功能，将列别名书写为对象属性名，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回
			
		26.Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？
			虽然Mybatis解析Xml映射文件是按照顺序解析的，但是被引用的B标签依然可以定义在任何地方
			原理：Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，
				  然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，
				  此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。
		
		27.MyBatis实现一对一，一对多有几种方式，怎么操作的？
			嵌套结果：嵌套结果是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成
			嵌套查询：先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，
			
		28.Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理？
			Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能
			9中动态sql：trim|where|set|foreach|if|choose|when|otherwise|bind。
			执行原理：使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。
			
		29.Mybatis是如何进行分页的？分页插件的原理是什么？
			Mybatis使用RowBounds对象进行分页
			原理：分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
		
		30.说说Mybatis的一级、二级缓存
			一级缓存： SqlSession级别缓存,缓存对象存储周期为第一次获取,到sqlsession被销毁掉,
			二级缓存：SqlSessionFactory级别缓存,缓存对象存储周期为第一次获取,到SqlSessionFactory被销毁掉(应用停止了)
			默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；
			
		31.Mybatis的核心组件有哪些？
			（1）SqlSessionFactoryBuilder （构造器）：它会根据配置或者代码来生成 SqISessionFactory
			（2）SqlSessionFactory （工厂接口）：依靠它来生成 SqlSession，使用的是工厂模式。
			（3）SqlSession （会话）： 一个既可以发送 SQL 执行返回结果，也可以获取 Mapper 的接 口。
			（4）SQL Mapper （映射器）：它负责发送SQL去执行， 并返回结果
			

十二.Mysql
	1.为什么要使用数据库？
		如果数据储存到内存中：优点是存取速度快，缺点是不能永久保存
		如果数据储存到磁盘中：优点是能够永久储存，缺点是效率不高
		所以我们用数据库保存数据，优点是：（1）数据永久保存；（2）使用SQL语句，查询方便效率高。（3）管理数据方便
		
	2.什么是SQL？它有什么作用？
		结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。
		作用：用于存取数据、查询、更新和管理关系数据库系统。
		
	3.什么是MySQL?
		MySQL是一个关系型数据库管理系统，它具有开源，体积小，速度快。适用于于中小型企业领域等特点
		
	4.数据库三大范式是什么？
		（1）第一范式：每个列都不可以再拆分
		（2）非主键列完全依赖于主键，而不能是依赖于主键的一部分
		（3）第三范式：在第二范式的基础上
		注意，可以不遵循三范式，比如为性能考虑，
		
	5.MySQL的binlog有有几种录入格式？分别有什么区别？
		（1）statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能
		（2）row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改
		（3）mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
		
	6.MySQL存储引擎MyISAM与InnoDB区别
		Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
		MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。
		
		
	7.InnoDB引擎的4大特性
		插入缓冲（insert buffer)
		二次写(double write)
		自适应哈希索引(ahi)
		预读(read ahead)
		
	8.什么是索引？
		索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。
		
	9.索引有哪些优缺点？
		优点：
			（1）可以大大加快数据的检索速度
			（2）通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。
		缺点： 
			（1）创建索引和维护索引要耗费时间
			（2）索引需要占物理空间。
		
	10.索引有哪几种类型？
		（1）主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
		（2）唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引
		（3）普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。
		（4）全文索引： 是目前搜索引擎使用的一种关键技术。
		
	11.说一下索引的基本原理
		索引的原理很简单，就是把无序的数据变成有序的查询
		（1）把创建了索引的列的内容进行排序
		（2）对排序结果生成倒排表
		（3）在倒排表内容上拼上数据地址链
		（4）在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据
		
	12.创建索引的三种方式，删除索引有哪些方式？
		创建索引：
				（1）在执行CREATE TABLE时创建索引
				（2）使用ALTER TABLE命令去增加索引
				（3）使用CREATE INDEX命令创建
		删除索引：
				（1）根据索引名删除普通索引、唯一索引、全文索引
				（2）
				
	13.创建索引时需要注意什么？
		（1）非空字段   （2）取值离散大的字段  （3）索引字段越小越好
		
	14.百万级别或以上的数据如何删除？
		（1）所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）
		（2）然后删除其中无用数据（此过程需要不到两分钟）
		（3）删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。
		
	15.什么是脏读？幻读？不可重复读？
		（1）脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
		（2）不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，
		（3）幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致
		
	16.什么是事务的隔离级别？MySQL的默认隔离级别是什么？
		（1）未提交读：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
		（2）已提交读：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
		（3）可重复读：对同一字段的多次读取结果都是一致的，可以阻止脏读和不可重复读，但幻读仍有可能发生。
		（4）可串行化：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
		Mysql 默认采用的可重复读隔离级别 Oracle 默认采用的 已提交读隔离级别
		
	17.按照锁的粒度分数据库锁有哪些？
		（1）行级锁 ：表示只针对当前操作的行进行加锁；   特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高
		（2）表级锁 ：表示对当前操作的整张表加锁；  特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。
		（3）页级锁：介于行级锁和表级锁中间的一种锁；    特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；并发度一般
		
	18.从锁的类别上分MySQL都有哪些锁呢？
		（1）共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个
		（2）排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。
		
	19.MySQL中InnoDB引擎的行锁是怎么实现的？
		InnoDB是基于索引来完成行锁
		
	20.InnoDB存储引擎的锁的算法有几种？
		（1）Record lock：单个行记录上的锁
		（2）Gap lock：间隙锁，锁定一个范围，不包括记录本身
		（3）Next-key lock：record+gap 锁定一个范围，包含记录本身
		
	21.什么是死锁？怎么解决？
		死锁：死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象
		解决方案：1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
				  2.在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
				  3.对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；
	22.数据库的乐观锁和悲观锁是什么？怎么实现的？
		悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制
		乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，实现方式：乐一般会使用版本号机制或CAS算法实现。
		使用场景：乐观锁适用于写比较少的情况下（多读场景）；一般多写的场景下用悲观锁就比较合适。
		
	23.大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？
		（1）限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句，比如最近一个月的订单
		（2）读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
		（3）缓存： 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；
		
	24.分库分表了是怎么做的？分表分库了有什么问题？
		主要有垂直分表和水平分表
		垂直分表：把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中
				缺点：（1）对于应用层来说，逻辑算法增加开发成本
					  （2）管理冗余列，查询所有数据需要join操作
				适用场景：（1）如果一个表中某些列常用，另外一些列不常用
		水平分表：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的
				缺点：（1）给应用增加复杂度，通常查询时需要多个表名
					  
		面临的问题：
			（1）事务支持 分库分表后，就成了分布式事务了
			（2）跨库join
			（3）数据迁移，容量规划，扩容等问题 
			
			
			
十三.分布式事务
	1.为什么要分布式事务？
		因为微服务项目往往有很多的数据库组成，如果在一个业务中涉及到了对多个微服务以及多个数据库的写操作(跨多个数据源)，那么保证多个数据库组件的读写一致
		这就需要使用分布式事务框架来实现
		
	2.什么是强一致性、弱一致性、最终一致性？
		强一致性：关系型数据库要求当数据写入数据库之后，马上就能读到写入的数据 
		弱一致性：能够容忍在写操作完成之后不要求所有数据都能马上读到.
		最终一致性：最终一致性也是弱一致性的一种，即数据写完之后，不保证什么时候能够读到数据，但是最终数据都会同步成功，最终都可以读到数据
		
	3..刚性事务具有ACID:关系型数据库使用的就是刚性事务是强一致性的典型例子，它严格遵循事务的ACID特性。
	
	4.BASE理论与柔性事务
		BASE理论是根据CAP理演化而来的，它牺牲了一致性得到了可用性，BASE理论允许数据在一段时间内是不一致的，但最终达到一致状态，如果银行转账24小时到账
		柔性事务：它不一定严格遵循事务的ACID四大特性。
		
	分布式事务的解决方案
	5.两阶段提交(2pc)
			XA规范协议是一种事务协议，通过这种协议来通知数据库事务的开始、结束、提交、以及回滚，XA协议使用二阶段提交来处理分布式事务，分布式事务的原子性，要么都成功，要么都失败。
			谓二阶段是有两个阶段组成，一阶段投票阶段和二阶段提交阶段。同时它是由“事务协调器”和若干“事务执行者”两个角色组成。
			
			第一阶段：准备阶段(投票阶段)：工作流程，工作原理
				1.事务协调器向所有事务参与者发请求，询问是否可以执行提交操作(你们都可以执行事务操作吗？)，并开始等待各参与者节点的响应。
				2.事务参与者收到协调者的指令开始执行事务操作但是不会提交事务，
					同时写Undo log(写操作之前首先将数据备份log,如果要回滚就从这个log进行数据还原) 和 Redo log(修改数据在buffer pool缓冲池中修改，Redo log是对这个缓冲池的内容做持久，避免修改的数据丢失) 。
				3.如果参与者事务操作都执行成功(注意哦，没提交事务哦)，那么就会回复 事务协调器 “准备OK” ，如果事务操作失败，那么就会回复执行者“准备不OK”。
			第二阶段Commit：
				正常流程：
				4.事务协调器会收到参与者的回复，如果所有的参与者都回复“准备ok”，意味着所有的参与者都可以完成事务操作，
					那么事务协调器会向每个事务参与者发送一个“commit” 提交事务指令(既然大家都可以进行事务操作，那大家都提交事务把)
				5.事务参与者收到指令就开始提交事务，然后会向事务协调器回复“完成”，事务协调器收到所有参与者都回复完成，事务完成。
				非正常流程：
				4.如果再第一阶段事务协调器收到了某个事务参与者回复“准备不ok”即事务操作执行失败，那么事务协调器会向所有的事务参与者发送“rollback”回滚执行
				5.事务参与者收到指令，回滚之前的事务操作，向事务协调者回复“回滚成功”，当事务协调器收到所有的参与者回复“回滚成功”后，取消事务。
				
	6.二阶段提交有哪些问题？
		（1）在第一阶段，如果参与者迟迟不回复协调者，就会造成事务的阻塞，性能不好。
		（2）单节点故障，如果协调器挂了，参与者会阻塞，
		（3）如果事务事务协调器发出“commit”指令后宕机，后面就不能接受信息了
		
	7.三阶段提交(3pc)
		PC在2PC的功能上做了两个改动，一是在协调者和事务参与者之间引入了超时机制，在第一阶段和第二阶段中插入一个准备阶段 ， 保证了在最后提交阶段之前各参与节点的状态是一致的
		第一阶段：
			（1）事务协调者向事务参与者发送请求询问是否能提交事务，然后等待所有事务参与者的返回信息
			（2)事务参与者接收到指令，然后自身认为能够提交事务则返回 “yes”否则返回“no”
			
		第二阶段:
			正常流程:
				（1）如果事务协调者收到所有的事务参与者的反馈结果都为YES，那么就进入papreCommit阶段(准备提交阶段)。事务协调者向事务参与者发送 “papreCommit”指令。
				（2）事务参与者收到“papreCommit”指令，开始进行事务操作，并将undo和redo信息记录到事务日志中，如果顺利执行事务操作，则反馈ACK确认信息，然后等待下一步指令
			非正常阶段：
				(1)如果事务协调者收到所有的事务参与者的反馈结果出现了NO,或者等待超时，那么就执行事务中断，向所有的事务参与者发送中断指令。
				(2)事务参与者接收到中断指令，中断事务，当然如果事务参与者迟迟未收到事务协调者的指令等待超时也会中断事务。
				
		第三阶段
			正常流程：
				（1）事务协调者收到所有的事务参与者的反馈结果都是ACK，然后向事务参与者发送提交事务指令，通知提交事务。
				（2）事务参与者收到提交事务指令，正式执行事务提交，并且释放所有事务资源，返回向事务协调者返回事务结果状态“ACK”完成
				（3）事务协调者收到所有的事务参与者都返回ACK成功,完成事务。
			非正常流程：	
				（1）事务协调者收到的事务参与者的反馈结果有的不是ACK，那么事务协调者然后向事务参与者发送事务中断指密令。
				（2）事务参与者收到事务中断指密令，会根据日志文件还原数据，然后释放事务资源，然后向事务协调者发送回滚“ACK”消息
				（3）事务协调者收到所有的事务参与者都返回ACK消息,取消事务。
				
	8.三阶段提交会出现什么问题？.
		3pc的问题是数据不一致，比如全局事务取消了，但是某一个事务参与者么有收到事务取消的指令，等待一段时间后会选择自动commit,这样就会造成数据不一致的情况。
		
	9..TCC事物补偿
		TCC(Try Confirm Cancel) 事务补偿机制，即每一个操作都要做相应的补偿机制，即如何确认操作成功，如果操作失败如何撤销事务。它分为三个阶段
		 
			Try：这个步骤是用来做业务的预处理，可以理解为是做一些准备工作
				
			Confirm ：确认，如果所有的事务参与者都try成功，执行commit对业务做提交操作
			Cancel：取消，如果try失败需要回滚，即取消try的预处理操作
			
			
Swagger是什么？有什么用？
	Swagger 是一个规范且完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务
	作用：支持 API 自动生成同步的在线文档
		  提供 Web 页面在线测试 API
		  
项目中怎么集成的？
	1.引入Swagger和Swagger-ui依赖
	2.我拷贝了一个配置类，/对外暴露服务的包,以controller的方式暴露
	

实现第三方登录（微信登录）需要有哪些参数，流程看笔记
	1.回掉域名    2.APPID  3.密钥   （应用生成RSA密钥，RSA密钥包含应用私钥(APP_PRIVATE_KEY)、应用公钥(APP_PUBLIC_KEY），
									生成密钥后在开放平台开发者中心进行密钥配置，配置完成后可以获取支付宝公钥(ALIPAY_PUBLIC_KEY)。）
	4.三个url地址（获取授权码地址，获取token令牌的地址，获取用户信息的地址）

图片验证码实现
	随机数和图片整合，图片基于Base64编码成字符串，响应给前端    图片的生成直接使用工具类
	
	
支付宝支付：流程看笔记
	内网穿透：用post请求方式访问我们的站点的每个controller的方法，外网支付宝也要访问，所以要让我们应用能够被外网访问，就要使用内网穿透技术
			  用natpp（免费的）
			  
	支付流程：1.点击支付，跳转到支付页面
			  2.支付以后，Ali后台会发送异步请求和同步，异步请求：到我们的后台，我们要接收支付宝返回过来的信息（商品订单号，支付单的信息<根据商品订单号获取的>）
				同步请求：跳转到支付状态的页面


订单取消（明天复习）
	如果用户迟迟没有进行支付，我们会自动取消订单-------使用定时器 时间一到就取消订单，
	


为什么会有跨域问题的出现？跨域问题怎么解决？
		跨域问题出现的原因：不同服务器之间的访问，会对请求有所拦截
		解决跨域问题：用nginx解决跨域问题 
		
nginx解决跨域问题的原理：
	使用Nginx转发请求。把跨域的接口写成（转换成）调本域的接口，然后将这些接口转发到真正的请求地址。
	
定时器quartz
	它有三个重要的组件：调度器，具体任务，触发器
		调度器：拷贝的一个工具类
		具体任务：
		
RPC和Http的不同：
	RPC主要用于公司内部的服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等。
	
	
	
十四.Linux 项目部署常用命令
	cd：切换文件的路径
	kill：杀死tomcat进程
	rm  -rf ：删除文件 
	vi 文件名：对指定的文件名进行编辑。
	clear 清屏
	
十五.
	

	